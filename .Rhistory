100*(patientcounts*gttrue)/(N*ntrial)
sum( 100*(patientcounts*gttrue)/(N*ntrial) )   # allocation percentage within 10% of theta
MTD_select
t[as.character(gts[gts>0])]
gttrue = as.vector(t(Gtrue))
alloc_perc <- sum( 100*(patientcounts*gttrue)/(N*ntrial) )   # allocation percentage within 10% of theta
library(LearnBayes)
d <- c(4,4)
K <- prod(d)
pmin <- 0.04
pmax <- 0.34
quantile1 <- list(p= 0.5^(1/K),x=pmax)
quantile2 <- list(p= 1-0.5^(1/K), x = pmin)
hyper_select <- beta.select(quantile1,quantile2)
A <- matrix(0,K,K)
for (i in 1:(K-1)){
if  (i%%d[2]!=0) {A[i,i+1]= 1}
if  (i<= (d[2]*(d[1]-1))){
A[i,i+d[2]]= 1
}
}
alpha <- beta <- rep(1,K)
Rcpp::sourceCpp('RcppArmaGibbs.cpp')
m <-  seq(hyper_select[1],sum(hyper_select),length.out= 15)
counter <- 0
gibbs_med <- gibbs_sd <- par <- c()
res = result = list()
hyperparameter_fx <- function(t, t2){
x = seq(0.2,t/2, length.out= 10)
y = seq(0.2,t2/2, length.out= 10)
z = seq(0.2,0.4,length.out= 3)
for (i in x){
for (j in y){
for (l in z){
gibbs_sample = GibbsPosterior(N,c(t-i,rep(l,K-2),j),c(i,rep(min(t/2,t2/2)-l,K-2),t2-j),rep(0,K),rep(0,K), 5000, 1000)
gibbs_med = rbind(gibbs_med,gibbs_sample$median)
gibbs_sd = rbind(gibbs_sd,gibbs_sample$sd)
par = rbind(par,c(t,t2,i,j,l))
counter = counter+1
cat(i)
cat("\n")
}
}
#}
}
res = list(gibbs_med=gibbs_med,gibbs_sd=gibbs_sd, par=par )
}
library(doParallel)
library(foreach)
comb <- function(...){
mapply('rbind', ..., SIMPLIFY = FALSE)
}
registerDoParallel(ncores)
system.time({
#result <- mclapply(m, hyperparameter_fx, mc.cores = ncores)
result <- foreach(t = m,
.combine = 'comb',
.multicombine = TRUE,
.init = list(list(), list(), list())) %:%
foreach (t2 = m, .combine = 'comb',
.multicombine = TRUE,
.init = list(list(), list(), list())) %dopar%{
out <- hyperparameter_fx(t, t2)
}
})
unlist_res <- function(res, numcol){
unlist_res <- matrix(unlist(t(res)), ncol=numcol, byrow = TRUE)
}
hyper_select
A <- matrix(0,K,K)
for (i in 1:(K-1)){
if  (i%%d[2]!=0) {A[i,i+1]= 1}
if  (i<= (d[2]*(d[1]-1))){
A[i,i+d[2]]= 1
}
}
alpha <- beta <- rep(1,K)
Rcpp::sourceCpp('RcppArmaGibbs.cpp')
m <-  seq(hyper_select[1],sum(hyper_select),length.out= 15)
counter <- 0
gibbs_med <- gibbs_sd <- par <- c()
res = result = list()
hyperparameter_fx <- function(t, t2){
x = seq(0.2,t/2, length.out= 10)
y = seq(0.2,t2/2, length.out= 10)
z = seq(0.2,0.4,length.out= 3)
for (i in x){
for (j in y){
for (l in z){
gibbs_sample = GibbsPosterior(N,c(t-i,rep(l,K-2),j),c(i,rep(min(t/2,t2/2)-l,K-2),t2-j),rep(0,K),rep(0,K), 5000, 1000)
gibbs_med = rbind(gibbs_med,gibbs_sample$median)
gibbs_sd = rbind(gibbs_sd,gibbs_sample$sd)
par = rbind(par,c(t,t2,i,j,l))
counter = counter+1
cat(i)
cat("\n")
}
}
#}
}
res = list(gibbs_med=gibbs_med,gibbs_sd=gibbs_sd, par=par )
}
library(doParallel)
library(foreach)
comb <- function(...){
mapply('rbind', ..., SIMPLIFY = FALSE)
}
registerDoParallel(ncores)
system.time({
#result <- mclapply(m, hyperparameter_fx, mc.cores = ncores)
result <- foreach(t = m,
.combine = 'comb',
.multicombine = TRUE,
.init = list(list(), list(), list())) %:%
foreach (t2 = m, .combine = 'comb',
.multicombine = TRUE,
.init = list(list(), list(), list())) %dopar%{
out <- hyperparameter_fx(t, t2)
}
})
gibbs_med <- gibbs_sd <- par <- c()
res = result = list()
hyperparameter_fx <- function(t, t2){
x = seq(0.2,t/2, length.out= 10)
y = seq(0.2,t2/2, length.out= 10)
z = seq(0.2,0.4,length.out= 3)
for (i in x){
for (j in y){
for (l in z){
gibbs_sample = GibbsPosterior(N,c(t-i,rep(l,K-2),j),c(i,rep(min(t/2,t2/2)-l,K-2),t2-j),rep(0,K),rep(0,K), 5000, 1000)
gibbs_med = rbind(gibbs_med,gibbs_sample$median)
gibbs_sd = rbind(gibbs_sd,gibbs_sample$sd)
par = rbind(par,c(t,t2,i,j,l))
counter = counter+1
cat(i)
cat("\n")
}
}
#}
}
res = list(gibbs_med=gibbs_med,gibbs_sd=gibbs_sd, par=par )
}
library(doParallel)
library(foreach)
comb <- function(...){
mapply('rbind', ..., SIMPLIFY = FALSE)
}
registerDoParallel(ncores)
system.time({
#result <- mclapply(m, hyperparameter_fx, mc.cores = ncores)
result <- foreach(t = m,
.combine = 'comb',
.multicombine = TRUE,
.init = list(list(), list(), list())) %:%
foreach (t2 = m, .combine = 'comb',
.multicombine = TRUE,
.init = list(list(), list(), list())) %dopar%{
out <- hyperparameter_fx(t, t2)
}
})
unlist_res <- function(res, numcol){
unlist_res <- matrix(unlist(t(res)), ncol=numcol, byrow = TRUE)
}
source('GibbsPosterior.R')
ncores= 15
library(LearnBayes)
ncores<-4
A <- matrix(0,K,K)
for (i in 1:(K-1)){
if  (i%%d[2]!=0) {A[i,i+1]= 1}
if  (i<= (d[2]*(d[1]-1))){
A[i,i+d[2]]= 1
}
}
alpha <- beta <- rep(1,K)
Rcpp::sourceCpp('RcppArmaGibbs.cpp')
m <-  seq(hyper_select[1],sum(hyper_select),length.out= 15)
counter <- 0
gibbs_med <- gibbs_sd <- par <- c()
res = result = list()
hyperparameter_fx <- function(t, t2){
x = seq(0.2,t/2, length.out= 10)
y = seq(0.2,t2/2, length.out= 10)
z = seq(0.2,0.4,length.out= 3)
for (i in x){
for (j in y){
for (l in z){
gibbs_sample = GibbsPosterior(N,c(t-i,rep(l,K-2),j),c(i,rep(min(t/2,t2/2)-l,K-2),t2-j),rep(0,K),rep(0,K), 5000, 1000)
gibbs_med = rbind(gibbs_med,gibbs_sample$median)
gibbs_sd = rbind(gibbs_sd,gibbs_sample$sd)
par = rbind(par,c(t,t2,i,j,l))
counter = counter+1
cat(i)
cat("\n")
}
}
#}
}
res = list(gibbs_med=gibbs_med,gibbs_sd=gibbs_sd, par=par )
}
library(doParallel)
library(foreach)
comb <- function(...){
mapply('rbind', ..., SIMPLIFY = FALSE)
}
registerDoParallel(ncores)
system.time({
#result <- mclapply(m, hyperparameter_fx, mc.cores = ncores)
result <- foreach(t = m,
.combine = 'comb',
.multicombine = TRUE,
.init = list(list(), list(), list())) %:%
foreach (t2 = m, .combine = 'comb',
.multicombine = TRUE,
.init = list(list(), list(), list())) %dopar%{
out <- hyperparameter_fx(t, t2)
}
})
K
hyper_select
A <- matrix(0,K,K)
for (i in 1:(K-1)){
if  (i%%d[2]!=0) {A[i,i+1]= 1}
if  (i<= (d[2]*(d[1]-1))){
A[i,i+d[2]]= 1
}
}
alpha <- beta <- rep(1,K)
Rcpp::sourceCpp('RcppArmaGibbs.cpp')
m <-  seq(hyper_select[1],sum(hyper_select),length.out= 15)
counter <- 0
gibbs_med <- gibbs_sd <- par <- c()
res = result = list()
hyperparameter_fx <- function(t, t2){
x = seq(0.2,t/2, length.out= 10)
y = seq(0.2,t2/2, length.out= 10)
z = seq(0.2,0.4,length.out= 3)
for (i in x){
for (j in y){
for (l in z){
gibbs_sample = GibbsPosterior(N,c(t-i,rep(l,K-2),j),c(i,rep(min(t/2,t2/2)-l,K-2),t2-j),rep(0,K),rep(0,K), 5000, 1000)
gibbs_med = rbind(gibbs_med,gibbs_sample$median)
gibbs_sd = rbind(gibbs_sd,gibbs_sample$sd)
par = rbind(par,c(t,t2,i,j,l))
counter = counter+1
cat(i)
cat("\n")
}
}
#}
}
res = list(gibbs_med=gibbs_med,gibbs_sd=gibbs_sd, par=par )
}
library(doParallel)
library(foreach)
comb <- function(...){
mapply('rbind', ..., SIMPLIFY = FALSE)
}
registerDoParallel(ncores)
system.time({
#result <- mclapply(m, hyperparameter_fx, mc.cores = ncores)
result <- foreach(t = m,
.combine = 'comb',
.multicombine = TRUE,
.init = list(list(), list(), list())) %:%
foreach (t2 = m, .combine = 'comb',
.multicombine = TRUE,
.init = list(list(), list(), list())) %dopar%{
out <- hyperparameter_fx(t, t2)
}
})
unlist_res <- function(res, numcol){
unlist_res <- matrix(unlist(t(res)), ncol=numcol, byrow = TRUE)
}
gibbs_med = unlist_res(result[[1]],K)
res = result = list()
hyperparameter_fx <- function(t, t2){
x = seq(0.2,t/2, length.out= 10)
y = seq(0.2,t2/2, length.out= 10)
z = seq(0.2,0.4,length.out= 3)
for (i in x){
for (j in y){
for (l in z){
gibbs_sample = GibbsPosterior(N,c(t-i,rep(l,K-2),j),c(i,rep(min(t/2,t2/2)-l,K-2),t2-j),rep(0,K),rep(0,K), 5000, 1000)
gibbs_med = rbind(gibbs_med,gibbs_sample$median)
gibbs_sd = rbind(gibbs_sd,gibbs_sample$sd)
par = rbind(par,c(t,t2,i,j,l))
counter = counter+1
cat(i)
cat("\n")
}
}
#}
}
res = list(gibbs_med=gibbs_med,gibbs_sd=gibbs_sd, par=par )
}
library(doParallel)
library(foreach)
comb <- function(...){
mapply('rbind', ..., SIMPLIFY = FALSE)
}
registerDoParallel(ncores)
system.time({
#result <- mclapply(m, hyperparameter_fx, mc.cores = ncores)
result <- foreach(t = m,
.combine = 'comb',
.multicombine = TRUE,
.init = list(list(), list(), list())) %:%
foreach (t2 = m, .combine = 'comb',
.multicombine = TRUE,
.init = list(list(), list(), list())) %dopar%{
out <- hyperparameter_fx(t, t2)
}
})
source('GibbsPosterior.R')
ncores= 15
library(LearnBayes)
d <- c(4,4)
K <- prod(d)
pmin <- 0.04
pmax <- 0.34
quantile1 <- list(p= 0.5^(1/K),x=pmax)
quantile2 <- list(p= 1-0.5^(1/K), x = pmin)
hyper_select <- beta.select(quantile1,quantile2)
A <- matrix(0,K,K)
for (i in 1:(K-1)){
if  (i%%d[2]!=0) {A[i,i+1]= 1}
if  (i<= (d[2]*(d[1]-1))){
A[i,i+d[2]]= 1
}
}
alpha <- beta <- rep(1,K)
Rcpp::sourceCpp('RcppArmaGibbs.cpp')
m <-  seq(hyper_select[1],sum(hyper_select),length.out= 15)
counter <- 0
gibbs_med <- gibbs_sd <- par <- c()
res = result = list()
hyperparameter_fx <- function(t, t2){
x = seq(0.2,t/2, length.out= 10)
y = seq(0.2,t2/2, length.out= 10)
z = seq(0.2,0.4,length.out= 3)
for (i in x){
for (j in y){
for (l in z){
gibbs_sample = GibbsPosterior(d,c(t-i,rep(l,K-2),j),c(i,rep(min(t/2,t2/2)-l,K-2),t2-j),rep(0,K),rep(0,K), 5000, 1000)
gibbs_med = rbind(gibbs_med,gibbs_sample$median)
gibbs_sd = rbind(gibbs_sd,gibbs_sample$sd)
par = rbind(par,c(t,t2,i,j,l))
counter = counter+1
cat(i)
cat("\n")
}
}
#}
}
res = list(gibbs_med=gibbs_med,gibbs_sd=gibbs_sd, par=par )
}
library(doParallel)
library(foreach)
comb <- function(...){
mapply('rbind', ..., SIMPLIFY = FALSE)
}
registerDoParallel(ncores)
system.time({
#result <- mclapply(m, hyperparameter_fx, mc.cores = ncores)
result <- foreach(t = m,
.combine = 'comb',
.multicombine = TRUE,
.init = list(list(), list(), list())) %:%
foreach (t2 = m, .combine = 'comb',
.multicombine = TRUE,
.init = list(list(), list(), list())) %dopar%{
out <- hyperparameter_fx(t, t2)
}
})
result
idx <- X != 0
ifelse(any(idx), max(which(idx)), 0)
mx <- function(X) {
idx <- X != 0
ifelse(any(idx), max(which(idx)), 0)
}
f <- function(n,method="zeta") {
if(method == "zeta"){
s <- 0
if (n >= 1) {
for (i in 1:n)
s =  s + 6/pi^2*(1/i^2)
}
return(s)
}else{
if(method == "tanh"){
return(tanh(n/5))
}
}
}
g <- function(n) {
# n has to be > 0
(f(n) - f(1))/(1 - f(1))  # 1 is f(\infty)
}
tox <- function(x){
s = 0
# K <- length(x)
mx_idx <- mx(x)
if (mx_idx == 0) return(0)
for (k in 1:mx_idx) {
s = s + ifelse(k == mx_idx, g(x[k]), f(x[k],"zeta")) / mx_idx
}
return(mx(x) + s)
}
tox(c(1,1,100,0,0))
tox(c(1,1,1000,0,0))
tox(c(1,2,1000,0,0))
tox(c(1,100,1000,0,0))
tox(c(100,100,1000,0,0))
tox <- function(x){
s = 0
# K <- length(x)
mx_idx <- mx(x)
if (mx_idx == 0) return(0)
for (k in 1:mx_idx) {
s = s + ifelse(k == mx_idx, g(x[k]), f(x[k],"tanh")) / mx_idx
}
return(mx(x) + s)
}
tox(c(100,100,1000,0,0))
tox(c(100,1,1000,0,0))
tox(c(1,1,1000,0,0))
tox <- function(x){
s = 0
# K <- length(x)
mx_idx <- mx(x)
if (mx_idx == 0) return(0)
for (k in 1:mx_idx) {
s = s + ifelse(k == mx_idx, g(x[k]), f(x[k],"zeta")) / mx_idx
}
return(mx(x) + s)
}
tox(c(1,1,1000,0,0))
x = 0:20
plot(x, f(x))
f(0)
f(1)
f(2)
f(20)
plot(f(x))
plot(x,f(x))
x
f(x)
y = apply(x,1,f)
y = apply(x,2,f)
sapply(x, f)
x = 0:20
y = sapply(x, f)
plot(x,y)
tox <- function(x){
s = 0
# K <- length(x)
mx_idx <- mx(x)
if (mx_idx == 0) return(0)
for (k in 1:mx_idx) {
s = s + ifelse(k == mx_idx, g(x[k]), f(x[k],"tanh")) / mx_idx
}
return(mx(x) + s)
}
y = sapply(x, f,"tanh")
y
x = 0:20
y = sapply(x, f,"tanh")
plot(x,y)
x = 0:20
y = sapply(x, f,"tanh")
plot(x,y)
y1 = sapply(x, f,"tanh")
y2 = sapply(x, f,"zeta", pch = 2)
y1 = sapply(x, f,"tanh")
y2 = sapply(x, f,"zeta")
plot(x,y1)
plot(x,y2)
plot(x,y1)
plot(x,y2)
plot(x,y2)
y1 = sapply(x, f,"tanh")
y2 = sapply(x, f,"zeta")
z1 = sapply(y1, g)
z2 = sapply(y2, g)
plot(x,z1)
plot(x,z2)
plot(x,z1)
plot(x,z2)
f(1)
z1
z2
x = 1:20
y1 = sapply(x, f,"tanh")
y2 = sapply(x, f,"zeta")
z1 = sapply(y1, g)
z2 = sapply(y2, g)
plot(x,z1)
plot(x,z2)
z1 = sapply(x, g)
z2 = sapply(x, g)
plot(x,z1)
plot(x,z2)
plot(x,z2)
plot(x,z1)
plot(x,z2)
plot(x,z1)
plot(x,z1)
plot(x,z2)
plot(x,y1)
plot(x,y2)
